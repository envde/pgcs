using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace PgCs.Common.CodeGeneration;

/// <summary>
/// Общие helper методы для работы с Roslyn syntax trees
/// </summary>
public static class RoslynSyntaxHelpers
{
    /// <summary>
    /// Создает header комментарий для auto-generated файлов
    /// </summary>
    public static SyntaxTriviaList CreateAutoGeneratedHeader()
    {
        return TriviaList(
            Comment("// <auto-generated>"),
            Comment(Environment.NewLine + "// This file was automatically generated by PgCs."),
            Comment(Environment.NewLine + "// DO NOT EDIT THIS FILE MANUALLY. Any changes will be lost on the next code generation."),
            Comment(Environment.NewLine + "// For more information, visit: https://github.com/yourusername/pgcs"),
            Comment(Environment.NewLine + "// </auto-generated>"),
            Comment(Environment.NewLine + Environment.NewLine)
        );
    }

    /// <summary>
    /// Создает compilation unit с namespace, usings и auto-generated header
    /// </summary>
    /// <param name="namespaceName">Имя namespace</param>
    /// <param name="memberDeclaration">Член namespace (class, record, enum и т.д.)</param>
    /// <param name="usings">Список using директив</param>
    /// <returns>CompilationUnitSyntax с настроенными usings, namespace и header</returns>
    public static CompilationUnitSyntax BuildCompilationUnit(
        string namespaceName,
        MemberDeclarationSyntax memberDeclaration,
        IEnumerable<string> usings)
    {
        // Создаем using директивы (distinct и sorted)
        var usingDirectives = usings
            .Distinct()
            .OrderBy(u => u)
            .Select(u => UsingDirective(IdentifierName(u)))
            .ToArray();

        // Создаем file-scoped namespace (C# 10+)
        var fileScopedNamespace = FileScopedNamespaceDeclaration(IdentifierName(namespaceName))
            .AddMembers(memberDeclaration);

        // Normalize сначала, потом добавляем header (иначе normalize удалит trivia)
        var compilationUnit = CompilationUnit()
            .AddUsings(usingDirectives)
            .AddMembers(fileScopedNamespace)
            .NormalizeWhitespace();

        // Создаем header с информацией о генерации
        var header = CreateAutoGeneratedHeader();

        return compilationUnit.WithLeadingTrivia(header);
    }

    /// <summary>
    /// Создает XML комментарий для документации
    /// </summary>
    /// <param name="summary">Текст summary элемента</param>
    /// <param name="remarks">Опциональный текст remarks элемента</param>
    /// <param name="addTrailingNewLine">Добавить перевод строки после комментария (используется в CustomTypeGenerator)</param>
    /// <returns>SyntaxTriviaList с XML документацией</returns>
    public static SyntaxTriviaList CreateXmlComment(
        string summary, 
        string? remarks = null,
        bool addTrailingNewLine = false)
    {
        var documentationElements = new List<XmlNodeSyntax>();

        // Создаем <summary> элемент
        var summaryLines = summary.Split('\n', StringSplitOptions.RemoveEmptyEntries);
        var summaryContent = new List<XmlNodeSyntax>();
        
        foreach (var line in summaryLines)
        {
            summaryContent.Add(XmlText(XmlTextLiteral(line.Trim())));
            if (line != summaryLines.Last())
            {
                summaryContent.Add(XmlText(XmlTextNewLine(Environment.NewLine, continueXmlDocumentationComment: false)));
            }
        }

        documentationElements.Add(XmlSummaryElement(summaryContent.ToArray()));

        // Если есть remarks, добавляем <remarks> элемент
        if (!string.IsNullOrWhiteSpace(remarks))
        {
            var remarksLines = remarks.Split('\n', StringSplitOptions.RemoveEmptyEntries);
            var remarksContent = new List<XmlNodeSyntax>();
            
            foreach (var line in remarksLines)
            {
                remarksContent.Add(XmlText(XmlTextLiteral(line.Trim())));
                if (line != remarksLines.Last())
                {
                    remarksContent.Add(XmlText(XmlTextNewLine(Environment.NewLine, continueXmlDocumentationComment: false)));
                }
            }

            documentationElements.Add(XmlRemarksElement(remarksContent.ToArray()));
        }

        // Создаем DocumentationComment trivia
        var triviaList = TriviaList(
            Trivia(DocumentationComment(documentationElements.ToArray())));

        // Добавляем перевод строки если требуется
        if (addTrailingNewLine)
        {
            triviaList = triviaList.Add(CarriageReturnLineFeed);
        }

        return triviaList;
    }
}
