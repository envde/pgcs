using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace PgCs.Common.CodeGeneration;

/// <summary>
/// Общие helper методы для работы с Roslyn syntax trees
/// </summary>
public static class RoslynSyntaxHelpers
{
    /// <summary>
    /// Создает header комментарий для auto-generated файлов
    /// </summary>
    public static SyntaxTriviaList CreateAutoGeneratedHeader()
    {
        return TriviaList(
            Comment("// <auto-generated>"),
            Comment(Environment.NewLine + "// This file was automatically generated by PgCs."),
            Comment(Environment.NewLine + "// DO NOT EDIT THIS FILE MANUALLY. Any changes will be lost on the next code generation."),
            Comment(Environment.NewLine + "// For more information, visit: https://github.com/yourusername/pgcs"),
            Comment(Environment.NewLine + "// </auto-generated>"),
            Comment(Environment.NewLine + "#nullable enable"),
            Comment(Environment.NewLine + Environment.NewLine)
        );
    }

    /// <summary>
    /// Создает compilation unit с namespace, usings и auto-generated header
    /// </summary>
    /// <param name="namespaceName">Имя namespace</param>
    /// <param name="memberDeclaration">Член namespace (class, record, enum и т.д.)</param>
    /// <param name="usings">Список using директив</param>
    /// <returns>CompilationUnitSyntax с настроенными usings, namespace и header</returns>
    public static CompilationUnitSyntax BuildCompilationUnit(
        string namespaceName,
        MemberDeclarationSyntax memberDeclaration,
        IEnumerable<string> usings)
    {
        // Создаем using директивы (distinct и sorted)
        var usingDirectives = usings
            .Distinct()
            .OrderBy(u => u)
            .Select(u => UsingDirective(IdentifierName(u)))
            .ToArray();

        // Создаем file-scoped namespace (C# 10+)
        var fileScopedNamespace = FileScopedNamespaceDeclaration(IdentifierName(namespaceName))
            .AddMembers(memberDeclaration);

        // Normalize с сохранением elastic trivia (это позволит сохранить XML комментарии)
        var compilationUnit = CompilationUnit()
            .AddUsings(usingDirectives)
            .AddMembers(fileScopedNamespace)
            .NormalizeWhitespace(elasticTrivia: true);

        // Создаем header с информацией о генерации
        var header = CreateAutoGeneratedHeader();

        return compilationUnit.WithLeadingTrivia(header);
    }

    /// <summary>
    /// Создает XML комментарий для документации
    /// </summary>
    /// <param name="summary">Текст summary элемента</param>
    /// <param name="remarks">Опциональный текст remarks элемента</param>
    /// <param name="addTrailingNewLine">Добавить перевод строки после комментария (используется в CustomTypeGenerator)</param>
    /// <returns>SyntaxTriviaList с XML документацией</returns>
    public static SyntaxTriviaList CreateXmlComment(
        string summary, 
        string? remarks = null,
        bool addTrailingNewLine = false)
    {
        var documentationElements = new List<XmlNodeSyntax>();

        // Создаем <summary> элемент
        var summaryLines = summary.Split('\n', StringSplitOptions.RemoveEmptyEntries);
        var summaryContent = new List<XmlNodeSyntax>();
        
        foreach (var line in summaryLines)
        {
            summaryContent.Add(XmlText(XmlTextLiteral(line.Trim())));
            if (line != summaryLines.Last())
            {
                summaryContent.Add(XmlText(XmlTextNewLine(Environment.NewLine, continueXmlDocumentationComment: false)));
            }
        }

        documentationElements.Add(XmlSummaryElement(summaryContent.ToArray()));

        // Если есть remarks, добавляем <remarks> элемент
        if (!string.IsNullOrWhiteSpace(remarks))
        {
            var remarksLines = remarks.Split('\n', StringSplitOptions.RemoveEmptyEntries);
            var remarksContent = new List<XmlNodeSyntax>();
            
            foreach (var line in remarksLines)
            {
                remarksContent.Add(XmlText(XmlTextLiteral(line.Trim())));
                if (line != remarksLines.Last())
                {
                    remarksContent.Add(XmlText(XmlTextNewLine(Environment.NewLine, continueXmlDocumentationComment: false)));
                }
            }

            documentationElements.Add(XmlRemarksElement(remarksContent.ToArray()));
        }

        // Создаем DocumentationComment trivia
        var triviaList = TriviaList(
            Trivia(DocumentationComment(documentationElements.ToArray())));

        // Добавляем перевод строки если требуется
        if (addTrailingNewLine)
        {
            triviaList = triviaList.Add(CarriageReturnLineFeed);
        }

        return triviaList;
    }

    /// <summary>
    /// Форматирует XML документацию в сгенерированном коде.
    /// NormalizeWhitespace() сжимает XML comments в одну строку, поэтому нужна post-обработка.
    /// </summary>
    public static string FormatXmlDocumentation(string sourceCode)
    {
        // Паттерн для поиска XML комментариев в одну строку
        // Ищем: ///<summary>text</summary><returns>text</returns> и т.д.
        var pattern = @"\/\/\/(<summary>.*?<\/summary>)(<param.*?<\/param>)*(<returns>.*?<\/returns>)?";
        
        var result = System.Text.RegularExpressions.Regex.Replace(sourceCode, pattern, match =>
        {
            var sb = new System.Text.StringBuilder();
            var xmlContent = match.Value.Substring(3); // Убираем ///
            
            // Разбираем и форматируем каждый тег
            xmlContent = System.Text.RegularExpressions.Regex.Replace(xmlContent, @"<summary>(.*?)<\/summary>", m =>
            {
                sb.AppendLine("/// <summary>");
                sb.AppendLine($"/// {m.Groups[1].Value}");
                sb.Append("/// </summary>");
                return "";
            });
            
            // Обрабатываем <param> теги
            xmlContent = System.Text.RegularExpressions.Regex.Replace(xmlContent, @"<param name=""(.*?)"">(.*?)<\/param>", m =>
            {
                sb.AppendLine();
                sb.Append($"/// <param name=\"{m.Groups[1].Value}\">{m.Groups[2].Value}</param>");
                return "";
            });
            
            // Обрабатываем <returns> тег
            xmlContent = System.Text.RegularExpressions.Regex.Replace(xmlContent, @"<returns>(.*?)<\/returns>", m =>
            {
                sb.AppendLine();
                sb.AppendLine("/// <returns>");
                sb.AppendLine($"/// {m.Groups[1].Value}");
                sb.AppendLine("/// </returns>");
                return "";
            });
            
            // Добавляем перенос строки ПОСЛЕ XML-документации
            sb.AppendLine();
            
            return sb.ToString();
        }, System.Text.RegularExpressions.RegexOptions.Singleline);
        
        // Дополнительная обработка: если после </returns> сразу идет код (без пустой строки), добавляем перенос
        result = System.Text.RegularExpressions.Regex.Replace(result, @"(/// </returns>)(\w)", "$1\n    $2");
        
        return result;
    }
}
